
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5.5. Path Planning &#8212; Introduction to Robotics and Perception</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/style.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5.6. Deep Learning" href="S56_diffdrive_learning.html" />
    <link rel="prev" title="5.4. Computer Vision 101" href="S54_diffdrive_perception.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-312077-7', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Robotics and Perception</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction to Robotics and Perception
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="S10_introduction.html">
   1. Introduction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="S11_intro_state.html">
     1.1. Representing State
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S12_intro_actions.html">
     1.2. Robot Actions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S13_intro_sensing.html">
     1.3. Sensing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S14_intro_perception.html">
     1.4. Perception
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S15_intro_decision.html">
     1.5. Planning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S16_intro_learning.html">
     1.6. Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="S20_sorter_intro.html">
   2. A Trash Sorting Robot
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="S21_sorter_state.html">
     2.1. Modeling the World State
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S22_sorter_actions.html">
     2.2. Actions for Sorting Trash
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S23_sorter_sensing.html">
     2.3. Sensors for Sorting Trash
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S24_sorter_perception.html">
     2.4. Perception
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S25_sorter_decision_theory.html">
     2.5. Decision Theory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S26_sorter_learning.html">
     2.6. Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="S30_vacuum_intro.html">
   3. A Robot Vacuum Cleaner
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="S31_vacuum_state.html">
     3.1. Modeling the State of the Vacuum Cleaning Robot
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S32_vacuum_actions.html">
     3.2. Actions over time
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S33_vacuum_sensing.html">
     3.3. Dynamic Bayes Nets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S34_vacuum_perception.html">
     3.4. Perception with Graphical Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S35_vacuum_decision.html">
     3.5. Markov Decision Processes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S36_vacuum_RL.html">
     3.6. Reinforcement Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="S40_logistics_intro.html">
   4. Warehouse Robots in 2D
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="S41_logistics_state.html">
     4.1. Continuous State
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S42_logistics_actions.html">
     4.2. Moving in 2D
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S43_logistics_sensing.html">
     4.3. Sensor Models with Continuous State
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S44_logistics_perception.html">
     4.4. Localization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S45_logistics_planning.html">
     4.5. Planning for Logistics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S46_logistics_learning.html">
     4.6. Some System Identification
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="S50_diffdrive_intro.html">
   5. A Mobile Robot With Simple Kinematics
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="S51_diffdrive_state.html">
     5.1. State Space for a Differential Drive Robot
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S52_diffdrive_actions.html">
     5.2. Motion Model for the Differential Drive Robot
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S53_diffdrive_sensing.html">
     5.3. Robot Vision
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S54_diffdrive_perception.html">
     5.4. Computer Vision 101
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     5.5. Path Planning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S56_diffdrive_learning.html">
     5.6. Deep Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="S60_driving_intro.html">
   6. Autonomous Vehicles
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="S61_driving_state.html">
     6.1. Planar Geometry
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S62_driving_actions.html">
     6.2. Kinematics for Driving
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S63_driving_sensing.html">
     6.3. Sensing for Autonomous Vehicles
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S64_driving_perception.html">
     6.4. SLAM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S65_driving_planning.html">
     6.5. Planning for Autonomous Driving.
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S66_driving_DRL.html">
     6.6. Deep Reinforcement Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="S70_drone_intro.html">
   7. Autonomous Drones in 3D
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="S71_drone_state.html">
     7.1. Moving in Three Dimensions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S72_drone_actions.html">
     7.2. Multi-rotor Aircraft
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S73_drone_sensing.html">
     7.3. Sensing for Drones
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S74_drone_perception.html">
     7.4. Visual SLAM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="S75_drone_planning.html">
     7.5. Trajectory Optimization
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/S55_diffdrive_planning.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/gtbook/robotics"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/gtbook/robotics/issues/new?title=Issue%20on%20page%20%2FS55_diffdrive_planning.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/gtbook/robotics/main?urlpath=tree/S55_diffdrive_planning.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#configuration-space-obstacles">
   5.5.1. Configuration Space Obstacles
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#value-iteration">
   5.5.2. Value Iteration
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#artificial-potential-fields">
   5.5.3. Artificial Potential Fields
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#probabilistic-road-maps-prms">
   5.5.4. Probabilistic Road Maps (PRMs)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rrt">
   5.5.5. RRT
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-rrt-implementation">
   5.5.6. A Simple RRT Implementation
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Path Planning</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#configuration-space-obstacles">
   5.5.1. Configuration Space Obstacles
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#value-iteration">
   5.5.2. Value Iteration
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#artificial-potential-fields">
   5.5.3. Artificial Potential Fields
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#probabilistic-road-maps-prms">
   5.5.4. Probabilistic Road Maps (PRMs)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rrt">
   5.5.5. RRT
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-simple-rrt-implementation">
   5.5.6. A Simple RRT Implementation
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <p><a href="https://colab.research.google.com/github/gtbook/robotics/blob/main/S55_diffdrive_planning.ipynb" target="_parent"><img alt="Open In Colab" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<div class="tex2jax_ignore mathjax_ignore section" id="path-planning">
<h1><span class="section-number">5.5. </span>Path Planning<a class="headerlink" href="#path-planning" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Samples are useful for planning as well.</p>
</div></blockquote>
<p><strong>This Section is still in draft mode and was released for adventurous spirits (and TAs) only.</strong></p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<div class="output text_html">
<div align='center'>
<img src='https://github.com/gtbook/robotics/blob/main/Art/steampunk/S55-Two-wheeled%20Toy%20Robot-03.jpg?raw=1' style='height:256 width:100%'/>
</div>
</div></div>
</div>
<p>Path planning is the problem of finding a collision-free path for
the robot from its starting configuration to a goal configuration.
This is one of the oldest fundamental problems in robotics.
Ideally, a path planning algorithm would guarantee to find a collision-free path whenever such a path
exists. Such algorithms are said to be <strong>complete</strong>.
Unfortunately, it has been shown that the path planning problem is NP complete.
Numerous hardness results have been obtained for different versions of the problem,
but the sad fact is that planning collision-free paths is generally intractable
for even moderately complex robotic systems.
For this reason, modern path planning algorithms try to strike a balance between
completeness (often settling for weaker variations on this idea)
and efficiency,
while finding solution paths for most typical problems.</p>
<p>In this section, we will describe several approaches to path planning,
all of which operate in the configuration space, to illustrate
the range of trade-offs that exist in this domain.</p>
<div class="section" id="configuration-space-obstacles">
<h2><span class="section-number">5.5.1. </span>Configuration Space Obstacles<a class="headerlink" href="#configuration-space-obstacles" title="Permalink to this headline">¶</a></h2>
<p>Although the robot moves physically in its workspace, the path planning problem is more easily addressed
if we work directly in the robot’s configuration space.
As in Section 5.2, we will denote a robot configuration by <span class="math notranslate nohighlight">\(q\)</span> and the configuration space of the robot by <span class="math notranslate nohighlight">\({\cal Q}\)</span>.
In order to plan collision-free paths, it is useful to partition the configuration space into
the set of collision-free configurations, <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{free}\)</span> (often called the <em>free configuration space</em>)
and the set of configurations that result in a collision, <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span>,
which is sometimes referred to as the <em>configuration space obstacle region</em>.</p>
<p>Let <span class="math notranslate nohighlight">\(R(q)\)</span> denote the set of points in the workspace that are occupied by the robot when the robot is in configuration <span class="math notranslate nohighlight">\(q\)</span>,
and let <span class="math notranslate nohighlight">\({\cal O}\)</span> denote the obstacle region in the workspace.
We can define the set <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span> as</p>
<div class="math notranslate nohighlight">
\[
{\cal Q}_\mathrm{obst} = \{ {\cal Q} \mid R(q) \cap {\cal O} = \emptyset \}
\]</div>
<p>The free configuration space is merely the complement of this set in <span class="math notranslate nohighlight">\(\cal Q\)</span>:</p>
<div class="math notranslate nohighlight">
\[
{\cal Q}_\mathrm{free} = {\cal Q} \setminus {\cal Q}_\mathrm{obst}
\]</div>
<p>We can now formally define a free path as a continuous map from the unit interval
(or any convenient interval that represents path length) as <span class="math notranslate nohighlight">\(\gamma : [0,1] \rightarrow {\cal Q}_\mathrm{free}\)</span>,
such that <span class="math notranslate nohighlight">\(q(0) = q_\mathrm{init}\)</span> and <span class="math notranslate nohighlight">\(q(1) = q_\mathrm{goal}\)</span>.
In some cases we require that <span class="math notranslate nohighlight">\(\gamma\)</span> also be differentiable, but this will not be necessary for our DDR.</p>
<p>When the dimension of the configuration space is small (e.g., <span class="math notranslate nohighlight">\({\cal Q} \subset \mathbb{R}^2\)</span>),
it may be possible to explicitly compute <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{free}\)</span>;
however, the time required for this computation grows exponentially with the
dimension of the configuration space, so this approach is not taken for even moderately complex robotic systems.</p>
</div>
<div class="section" id="value-iteration">
<h2><span class="section-number">5.5.2. </span>Value Iteration<a class="headerlink" href="#value-iteration" title="Permalink to this headline">¶</a></h2>
<p>In Chapter 4 we saw how the value function could be used to plan a path that led a robot with stochastic actions to a goal while avoiding obstacles.
We can apply this same method to the problem of planning collision-free paths in the configuration space.
We merely place a large negative reward along the configuration space obstacle boundaries, and a large positive reward at the goal configuration.
We can then use value iteration to compute an approximation to the value function over <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{free}\)</span>,
and merely follow the gradient
of the value function from the robot’s initial configuration until it reaches the goal.
In cases where the robot’s actions are not stochastic, we merely replace the probabilistic action model by a conditional probability
function that assigns probability one to the action’s defined outcome
(i.e., there is no uncertainty in the result of applying the action).</p>
<p>There are several disadvantages to this approach.
First, to apply value iteration, we must first discretize the configuration space (e.g., using a 2D grid).
Thus, we are computing the value function over an approximate representation, the fidelity of which
depends on the resolution of the grid.
It is possible, if the resolution is not good enough, that this method could fail to find a path to
the goal, even if a path for the robot exists.
Second, even though our planning problem is to find a path from <span class="math notranslate nohighlight">\(q_\mathrm{init}\)</span> to <span class="math notranslate nohighlight">\(q_\mathrm{goal}\)</span>,
the value function encodes the cost to reach the goal from <em>every</em> cell in the grid, including parts
of the grid that may never be visited by the robot.
Therefore, using the value function to solve a single path planning problem can be very inefficient,
since it essentially computes a path to the goal from <em>every</em> configuration in the grid.
Finally, the cost of computing the value function grows exponentially with the dimension of the configuration space,
precluding the use of this method to plan paths for more complex robots.</p>
</div>
<div class="section" id="artificial-potential-fields">
<h2><span class="section-number">5.5.3. </span>Artificial Potential Fields<a class="headerlink" href="#artificial-potential-fields" title="Permalink to this headline">¶</a></h2>
<p>Instead of exhaustively applying value iteration to a 2D grid representation of the configuration space,
we could try to construct a function that can be expressed in closed-form, such that following
the gradient of this function would lead to the goal configuration while avoiding any configuration
space obstacles.
Artificial potential functions aim to do just this.</p>
<p>The basic idea is simple: define a potential function on <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{free}\)</span> with a single
global minimum at <span class="math notranslate nohighlight">\(q_\mathrm{goal}\)</span>, and with arbitrarily high potential values on
the boundary of <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span>.
Because such a function would be convex,
and because the potential increases arbitrarily at obstacle boundaries,
gradient descent will achieve the goal of constructing a collision-free path to the goal.
Unfortunately, we can almost never construct such a function.
Convexity is the problem; at the moment we introduce obstacles, it becomes very difficult to
construct a convex potential function with the desired behavior.</p>
<p>It is fairly easy, however, to construct a function with a minimum at <span class="math notranslate nohighlight">\(q_\mathrm{goal}\)</span>
(though it will likely be one of many minima for the function)
that ensures collision-free paths.
We can define such a potential function as</p>
<div class="math notranslate nohighlight">
\[
U(q) = U_\mathrm{attr}(q) + U_\mathrm{rep}(q)
\]</div>
<p>in which <span class="math notranslate nohighlight">\(U_\mathrm{attr}\)</span> is the <em>attractive potential</em> with a single global minimum at <span class="math notranslate nohighlight">\(q_\mathrm{goal}\)</span>,
and <span class="math notranslate nohighlight">\(U_\mathrm{rep}\)</span> is the repulsive potential, whose value goes to infinity on the boundary
of <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span>.</p>
<p>There are many possible candidates for these two potentials, but it the basic behavior
can be captured by using a parabolic well for <span class="math notranslate nohighlight">\(U_\mathrm{attr}\)</span>, and defining <span class="math notranslate nohighlight">\(U_\mathrm{rep}\)</span>
in terms of the inverse distance to the nearest obstacle:</p>
<div class="math notranslate nohighlight">
\[ 
U_\mathrm{attr}(q) = \frac{1}{2} \| q -  q_\mathrm{goal} \|^2 ~~~~~~~~~~~~ U_\mathrm{rep}(q) = \frac{1}{d(q)}
\]</div>
<p>in which <span class="math notranslate nohighlight">\(d(q)\)</span> is defined as the minimum distance from configuration <span class="math notranslate nohighlight">\(q\)</span> to the boundary of
<span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span></p>
<div class="math notranslate nohighlight">
\[ d(q) = \min_{q' \in \partial {\cal Q}_\mathrm{obst} } \| q - q'\|^{\frac{1}{2}}
\]</div>
<p>Path planning can now be implemented using simple gradient descent.
Let <span class="math notranslate nohighlight">\(q^0 = q_\mathrm{init}\)</span>, and iterate over <span class="math notranslate nohighlight">\(k\)</span> until <span class="math notranslate nohighlight">\(\| q^k - q_\mathrm{goal} \| &lt; \epsilon\)</span></p>
<div class="math notranslate nohighlight">
\[
q^{k+1} = q^k - \alpha \nabla U(q)
\]</div>
<p>Note that this algorithm stops making progress if <span class="math notranslate nohighlight">\(\nabla U(q)=\)</span>,
which occurs for any local minimum in the potential field.
This is the primary drawback for potential field planners.
Nevertheless, the method is fast, and can be very effective for path planning problems that
aren’t too difficult (e.g., when the path to the goal does not pass through the basin of attraction
for any local minimum in the field).</p>
<p>Note that the basic idea behind potential field planning is similar to the basic idea behind
using the value function to construct a path:
Create a function whose optimal value is at the goal
(this is a maximum of the value function, but a minimum of the potential fiels),
and assign high cost (or, in the case of the value function, negative reward)
along the boundary of <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span>.
Then use gradient descent to find the path to the goal.
A key difference between the two methods is that, while value iteration requires global
computation of the value function, potential field planning evaluates <span class="math notranslate nohighlight">\(U\)</span> (and <span class="math notranslate nohighlight">\(\nabla U\)</span>) <em>only</em>
at those <span class="math notranslate nohighlight">\(q^k\)</span> that lie on the constructed path to the goal.
This provides a significant increase in computational efficiency, and in many cases
it is possible to use potential fields methods for real-time applications.
The second key difference is that value functions always have a single optimum, and that gradient
descent is guaranteed to find it, unlike potential fields that are apt to be trapped
in local minima.</p>
</div>
<div class="section" id="probabilistic-road-maps-prms">
<h2><span class="section-number">5.5.4. </span>Probabilistic Road Maps (PRMs)<a class="headerlink" href="#probabilistic-road-maps-prms" title="Permalink to this headline">¶</a></h2>
<p>As discussed above, the value function is guaranteed to find a path because it essentially explores the entire configuration space (applying dynamic programming outward from the goal configuration), while potential field planning is efficient because it focuses computation on the search for an individual path.
A compromise approach would be to build a global representation, but to encode only a small number of
paths in that representation.
Probabilistic Road Maps (PRMs) do just this.</p>
<p>A PRM is a graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> that is embedded in the configuration space.
Vertices correspond to configurations, and edges correspond to free paths.
A PRM is constructed by randomly sampling the configuration space to generate
the set of vertices, rejecting any samples that lie in <span class="math notranslate nohighlight">\({\cal Q}_\mathrm{obst}\)</span>.
Once the vertices have been generated, a simple local path planner is used
to connect vertices <span class="math notranslate nohighlight">\(v,v'\)</span> when the corresponding configurations <span class="math notranslate nohighlight">\(q,q'\)</span> are sufficiently
close (e.g., <span class="math notranslate nohighlight">\(\|q - q'\| &lt; d_\mathrm{max}\)</span>).
It is common to use a simple straight-line planner for these connections: an
edge connecting <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(v'\)</span> is added to <span class="math notranslate nohighlight">\(E\)</span> when the straight-line path from <span class="math notranslate nohighlight">\(q\)</span> to <span class="math notranslate nohighlight">\(q'\)</span> is collision-free.
There are, of course, many variations, nuances, and implementation details that we cannot cover here,
but this is the basic algorithm: randomly generate configurations and connect neighboring configurations when
possible.</p>
<p>Once a PRM has been constructed, path planning proceeds in two steps.
First, generate vertices <span class="math notranslate nohighlight">\(v_\mathrm{init}\)</span> and <span class="math notranslate nohighlight">\(v_\mathrm{goal}\)</span>
corresponding to configurations <span class="math notranslate nohighlight">\(q_\mathrm{init}\)</span> and <span class="math notranslate nohighlight">\(q_\mathrm{goal}\)</span>, and connect these
to the existing graph.
Second, search the graph for a path from <span class="math notranslate nohighlight">\(v_\mathrm{init}\)</span> to <span class="math notranslate nohighlight">\(v_\mathrm{goal}\)</span> in <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>It should be clear that such a method has no hope to yield a complete algorithm.
The mere fact that every node in the graph is the result of random sampling is enough
to preclude any proof that this approach will guarantee to find a path when a path exists.
There is, however, another useful completeness concept that applies in this case.
Suppose a free path exists.
Let <span class="math notranslate nohighlight">\(p_f(n)\)</span> denote the probability that the algorithm fails to find a path
after adding <span class="math notranslate nohighlight">\(n\)</span> random vertices to the graph.
An path planning algorithm is said to be <strong>probabilistically complete</strong> if</p>
<div class="math notranslate nohighlight">
\[ \lim_{n\rightarrow \infty} p_f(n) = 0
\]</div>
<p>Not only are PRM methods probabilistically complete, but in addition
they have the property that <span class="math notranslate nohighlight">\(p_f(n)\)</span> decreases to zero exponentially as <span class="math notranslate nohighlight">\(n\)</span> increases.
This is a powerful result, even if it fails to provide a deterministic guarantee of completeness.</p>
</div>
<div class="section" id="rrt">
<h2><span class="section-number">5.5.5. </span>RRT<a class="headerlink" href="#rrt" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Grow a tree to the goal.</p>
</div></blockquote>
<p>An alternative to building a single, global PRM is to grow a random tree from the initial
configuration <span class="math notranslate nohighlight">\(q_\mathrm{init}\)</span> until one of the leaf nodes in the tree can be connected
to <span class="math notranslate nohighlight">\(q_\mathrm{goal}\)</span>.
This is the approach taken with Rapidly-Exploring Random Trees (RRTs).</p>
<p>An RRT is constructed by iteratively adding randomly generated nodes to an existing
tree.
Let <span class="math notranslate nohighlight">\(T_k\)</span> denote the tree that exists at the <span class="math notranslate nohighlight">\(k^{th}\)</span> iteration.
A new node is added to the tree as follows:</p>
<ol class="simple">
<li><p>Randomly choose a configuration <span class="math notranslate nohighlight">\(q_\mathrm{rand}\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(q_\mathrm{near}\)</span> be the node in the current tree <span class="math notranslate nohighlight">\(T_k\)</span> that is nearest to <span class="math notranslate nohighlight">\(q_\mathrm{rand}\)</span>.</p></li>
<li><p>Create a new node <span class="math notranslate nohighlight">\(q_\mathrm{new}\)</span> by taking a small step from <span class="math notranslate nohighlight">\(q_\mathrm{near}\)</span> in
the direction of <span class="math notranslate nohighlight">\(q_\mathrm{rand}\)</span>.</p></li>
</ol>
<p>As with PRMs, there are many variations, nuances, and implementation details,
but the above three steps capture the essential idea of RRTs.
For our DDR, <em>taking a small step</em> can be implemented by using a simple two-step straight-line planner.
First, rotate the DDR so that its steering direction “points toward” <span class="math notranslate nohighlight">\(q_\mathrm{rand}\)</span>.
Second, move in the forward direction by some fixed amount.</p>
<p>RRTs enjoy the same probabilistic completeness properties as PRM-based planners.
In addition, it has been shown that the distribution of nodes in the tree converges
to the sampling distribution (e.g., if <span class="math notranslate nohighlight">\(q_\mathrm{rand}\)</span> is generated by sampling from a uniform
distribution on the configuration space, then the distribution of nodes
in <span class="math notranslate nohighlight">\(T_k\)</span> will converge to a uniform distribution).</p>
</div>
<div class="section" id="a-simple-rrt-implementation">
<h2><span class="section-number">5.5.6. </span>A Simple RRT Implementation<a class="headerlink" href="#a-simple-rrt-implementation" title="Permalink to this headline">¶</a></h2>
<p>RRTs have become increasingly popular in the robot motion planning community, for reasons that will become more apparent when we revisit RRT-style planning for aerial drones in Chapter 7.
For now, we will use a very simple implementation of RRTs to construct motion plans for our DDR.
Because the DDR can turn in place, we have to only build an RRT on the <em>position</em> of the DDR.</p>
<p>First, we need to be able to generate new nodes and calculate the distance between them:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_random_node</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a random node in a square around the origin.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>


<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="n">p1</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Calculate the distance between 2 nodes.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_nearest_node</span><span class="p">(</span><span class="n">rrt</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">],</span> <span class="n">node</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find nearest point in RRT to given node (linear time).&quot;&quot;&quot;</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rrt</span><span class="p">)</span> <span class="o">-</span> <span class="n">node</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rrt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span>
</pre></div>
</div>
</div>
</div>
<p>A key sub-routine in the RRT is to “steer” the DDR from the a parent node in the tree to a random target point.
We adopt a rather simple strategy: turn towards the target, and drive some fraction of the distance:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">steer</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Steer towards the target point, going a fraction of the displacement.&quot;&quot;&quot;</span>
  <span class="n">displacement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">parent</span>
  <span class="k">return</span> <span class="n">parent</span> <span class="o">+</span> <span class="n">displacement</span> <span class="o">*</span> <span class="n">fraction</span>
</pre></div>
</div>
</div>
</div>
<p>The entire algorithm is given below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rapidly_exploring_random_tree</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">,</span> <span class="n">goal</span><span class="p">:</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">,</span> <span class="n">max_nodes</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build the RRT from `start` to `goal`&quot;&quot;&quot;</span>
    <span class="n">rrt</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_nodes</span><span class="p">):</span>
        <span class="n">random_node</span> <span class="o">=</span> <span class="n">generate_random_node</span><span class="p">()</span>
        <span class="n">nearest</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">find_nearest_node</span><span class="p">(</span><span class="n">rrt</span><span class="p">,</span> <span class="n">random_node</span><span class="p">)</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">steer</span><span class="p">(</span><span class="n">nearest</span><span class="p">,</span> <span class="n">random_node</span><span class="p">,</span> <span class="n">fraction</span><span class="p">)</span>
        <span class="n">rrt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
        <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">goal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found motion.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rrt</span><span class="p">,</span> <span class="n">parents</span>
    <span class="k">return</span> <span class="n">rrt</span><span class="p">,</span> <span class="n">parents</span>
</pre></div>
</div>
</div>
</div>
<p>We can now run it and visualize the resulting RRT:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">goal</span> <span class="o">=</span> <span class="n">gtsam</span><span class="o">.</span><span class="n">Point2</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">)</span>
<span class="n">rrt</span><span class="p">,</span> <span class="n">parents</span> <span class="o">=</span> <span class="n">rapidly_exploring_random_tree</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0. 0.] [9. 9.]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use plotly to visualize RRT</span>

<span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rrt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
  <span class="c1"># create line from parent to next node</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">rrt</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">node</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">px</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xs</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ys</span><span class="p">,</span> <span class="n">line_group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>

<span class="c1"># add start and goal as green points</span>
<span class="n">fig</span><span class="o">.</span><span class="n">add_scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">goal</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">goal</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> 
                  <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">update_xaxes</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">autorange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">scaleratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">update_yaxes</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">autorange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">scaleratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/S55_diffdrive_planning_26_0.png" src="_images/S55_diffdrive_planning_26_0.png" />
</div>
</div>
<p>You can see that the RRT fills up the entire area of interest.
The algorithm terminates when we get close to the goal.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="S54_diffdrive_perception.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">5.4. </span>Computer Vision 101</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="S56_diffdrive_learning.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">5.6. </span>Deep Learning</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Frank Dellaert and Seth Hutchinson<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>